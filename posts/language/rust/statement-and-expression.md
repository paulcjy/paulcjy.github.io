---
title: 구문과 표현식
slug: rust-statement-and-expression
created: 2025-04-08 19:19
updated:
description:
category: rust
tags:
published: true
---

러스트에서 코드는 주로 구문과 표현식으로 구성된다.
이것은 다른 언어에는 없는 개념이다.

- 구문: 어떤 동작을 수행하고 값을 반환하지 않는 명령
- 표현식: 결괏값을 평가

## 구문

```rust
fn main() {
  let y = 6;
}
```

`let{:rust}` 키워드로 변수를 만들고 값을 할당하는 것은 구문이다.
따라서 `let y = 6;{:rust}`는 구문이다.

함수 정의 또한 구문이다.
따라서 위 예제는 그 자체로 구문에 해당한다.

구문은 값을 반환하지 않으므로 `let x = (let y = 6);{:rust}`처럼 `let{:rust}` 구문을 다른 변수에 할당할 수 없다.

## 표현식

```rust
fn main() {
  let a = 3;      // 표현식: 3
  let b = 2 + 4;  // 표현식: 2 + 4
  let c = a + b;  // 표현식: a + b

  // 중괄호로 만든 스코프 블럭도 표현식
  let y = {
    let x = 3;
    x + 1
  }

  println!("y: {y}");  // 매크로 호출도 표현식

  another_function();  // 함수 호출도 표현식
}

fn another_function() {
  ...
}
```

표현식은 어떤 값을 평가한다.
예를 들어, `5 + 6`은 `11`이라는 값을 평가하는 표현식이다.
표현식은 구문의 일부일 수 있다.

`let{:rust}` 구문에서 `=` 오른쪽의 부분도 표현식이다.
중괄호로 만들어진 스코프 블럭, 함수 호출, 매크로 호출도 모두 표현식이다.

```rust
let y = {
  let x = 3;
  x + 1
}
```

이 예제에서 중괄호로 만든 코드 블럭은 `4`를 평가하는 코드 블럭이다.
`let y = { ... }{:rust}`구문에서`y`에는 `4`가 바인딩된다.
주의할 점은 마지막 줄의 `x + 1{:rust}`이 세미콜론으로 끝나지 않았다는 것이다.
표현식은 종결을 나타내는 세미콜론을 쓰지 않는다.
만약 `x + 1;{:rust}`로 작성할 경우, 표현식은 구문으로 변경되고, 코드 블럭은 값을 반환하지 않는다.

이는 함수에서도 마찬가지이다.
함수의 반환값을 쓸 때는 표현식을 사용한다.

> *The Rust Programming Language*의 함수 부분에서는 등장하지 않았지만, 러스트에도 `return` 키워드가 존재한다.
> 함수 중간에 함수를 종료하고 싶다면 `return`을 사용할 수 있다.
>
> 그러나 러스트에서는 `return` 키워드 없이 마지막 표현식을 반환하는 스타일을 관용적으로 선호한다.
> 이는 러스트가 표현식 기반의 언어이고 함수형 프로그래밍 패러다임이 반영되었기 때문이라고 한다.
